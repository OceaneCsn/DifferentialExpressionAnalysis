---
title: "Clustering de gènes"
author: "Océane Cassan"
date: "10/25/2019"
output: 
  rmdformats::material:
    fig_width: 12
    highlight: kate
    includes:
        after_body: footer.html
---
#rmarkdown::render("ClusteringCoseq.Rmd")
```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr, warn.conflicts = F, quietly = T)
library(rmdformats, warn.conflicts = F, quietly = T)

## Global options
options(max.print="75")
opts_chunk$set(cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.align = "center")
opts_knit$set(width=75)
setwd("~/Documents/RNADifferentialAnalysis/DifferentialExpressionAnalysis/")
suppressMessages(library(ggplot2))
suppressMessages(library(coseq))
suppressMessages(library(DESeq2))
suppressMessages(library(HTSCluster))
suppressMessages(library(dplyr, warn.conflicts = F, quietly = T))
suppressMessages(library(biomartr, warn.conflicts = F, quietly = T))
suppressMessages(library(biomaRt, warn.conflicts = F, quietly = T))
suppressMessages(library(ade4, warn.conflicts = F, quietly = T))
suppressMessages(library(adegraphics, warn.conflicts = F, quietly = T))
suppressMessages(library(clusterProfiler, warn.conflicts = F, quietly = T))
suppressMessages(library(DOSE, warn.conflicts = F, quietly = T))
suppressMessages(library(rlist, warn.conflicts = F, quietly = T))
suppressMessages(library(org.At.tair.db, warn.conflicts = F, quietly = T))
```

On cherche à faire du clustering de gènes, sur ceux qui ont été détectés comme différentiellement exprimés lors du traitement au KNO3 des plantes WT.

# Gènes différentiellement exprimés

```{r data}
data = read.table("quantif_all_unstranded.txt", h=F)
colnames(data) <- c("Gene", "WT.K1", "WT.K2","WT.N1","WT.N2","WT.K3","WT.N3")
rownames(data)=data$Gene
data = dplyr::select(data, -c("Gene"))
genes = which(!(grepl("__", rownames(data))))
data = data[genes,]
data = data[, sort(colnames(data))]
#kable(head(data))
```


On procède à l'analyse d'expression différentielle pour obtenir les gènes d'intêret.

```{r DEgenes, cache = T}
design = data.frame(
   row.names = colnames( data ),
   condition = c( "untreated", "untreated", "untreated",
      "treated", "treated", "treated"),
   libType = rep("single-end", 6))

dds <- DESeq2::DESeqDataSetFromMatrix(countData = data,
                              colData = design,
                              design = ~ condition)
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dds$condition <- relevel(dds$condition, ref = "untreated")
dds <- DESeq2::DESeq(dds)
res <- na.omit(results(dds))
resOrdered <- res[order(res$padj),]
sum(res$padj < 0.05, na.rm=TRUE)
plotMA(res, ylim=c(-5,5))
DEgenes <- rownames(res[res$padj < 0.05,])
```

# Mixture Models theory 

## Estimation des clusters

Manière probabiliste de faire du soft clustering. (Contrairement au hard clustering, un point appartient à tous les clusters mais avec une certitude plus ou moins grande). 

Chaque cluster correspond à une distribution multivarée, dont on veut estimer les paramètres (Moyenne et écart type dans le cas Gaussien, Moyenne dans le cas de Poisson...).


Cette estimation se fait par des aglorithmes EM : Expectation Maximisation.
Fonctionnement EM (semblable à k-means avec des distributions à paramétrer plutôt que la position d'un centroide): 


- On suppose des paramètres randoms pour chaque cluster


- On calcule la probabilité de chaque point relativement à chaque cluster (Comme on connait les paramètres de chaque cluster, on peut calculer les probabilités de chaque point d'appartenir à chaque cluster, en utilisant la formule de Bayes)


- On ajuste les paramètres des clusters pour mieux coller aux points qui leur ont été assignés


- On réitère jusqu'à la convergence (par exemple mesurée par une différence de vraissemblance globale)

## Choix du nombre de clusters

On calcule la vraissemblance des données sous l'hypothèse qu'elle est générée par un mixture model.

$L = \Sigma_{i = 1}^n log\Sigma_{k = 1}^K P(x_i|k)P(k)$

Cependant, avec cette formule, on aurait autant de clusters que de points pour optimiser la vraissemblance.

On pénalise donc la vraissemblance par rapport au nombre de clusters.

On peut aussi utiiser le BIC ou l'AIC pour rester parcimonieux dans le nombre de clusters.

# Clustering avec Coseq

On donne en entrée la matrice de counts, et éventuellement une liste de gènes DE pour ne pas à avoir tous les gènes à traiter pour le clustering. 
On normalise avec la méthode de DESeq2 ou EdgeR entre autres, beaucoup sont disponibles.
On choisi le modèle, Normal ou Poisson, et le nombre de clusters à tester.

```{r coseq,cache=T}
data <- data[DEgenes,]
conds <- c(rep("K", 3), rep("N",3))
run_pois <- coseq(data, conds=conds, K=2:10, model="Poisson",iter = 5, transformation = "none")
coseq::plot(run_pois)
summary(run_pois)
clusters_per_genes <- clusters(run_pois)
```
Par curiosité, les distributions fittées de chaque cluster :
```{r coseq,cache=T}
nb_clust = max(clusters_per_genes)
col = 1

poisson <- function(x, lambda){
  return(lambda^x*exp(-lambda)/factorial(x))
}
for (clust in seq(1:nb_clust)){
  X = c()
  for(name in colnames(data)[grepl("WT", colnames(data))]){
    X = c(X, log(data[data$cluster == clust, name]+0.001))
  }
  print(X)
  m <- mean(exp(X))
  print(m)
  if(clust == 1) plot(density(X), col=col, lwd=2, xlim = c(0,13), main = "Counts density for each cluster")
  else lines(density(X), col=col, lwd=2)
  lines(log(poisson(seq(1,13, by = 0.01), lambda = exp(m))), lty = 2, col = col)
  col = col+1
}
```


# Visualisations 

Représentation du clustering dans le plan principal d'une ACP faite sur le log de l'expression:

On remarque principalement que les axes portant le plus de variabilité sont : 

- L'expression moyenne (abscisse de l'acp)

- La différence d'expression entre K et N (ordonnée de l'ACP). Le clustering a été fait sur la force et le "sens" (up ou down) de l'expression différentielle, d'où cette apparence de "couches" parallèles pour les clusters.


J'essaie aussi des représentations dans d'autres espaces, juste dans une optique exploratoire.

```{r adeACP}
data$cluster = clusters_per_genes[as.vector(rownames(data))]
data$regul <- ifelse(rowMeans(logData[c("WT.K1","WT.K2","WT.K3")]) < rowMeans(logData[c("WT.N1","WT.N2","WT.N3")]), "up-regulated", "down-regulated")
acp <- dudi.pca(log(data[c("WT.K1","WT.K2","WT.K3","WT.N1","WT.N2","WT.N3")]+0.1), center = TRUE, scale = TRUE, scan = FALSE)

library("RColorBrewer")

s.corcircle(acp$co)
adegraphics::s.class(acp$li, as.factor(data$cluster), labels = as.character(levels(as.factor(data$cluster))), col = brewer.pal(n = 10, name = "Paired"), chullSize = 1, ellipseSize = 0, plabels.cex = 0.7, pbackground.col = "grey85", main = "Clusters dans le plan principal", ylim = c(-4, 4))
#insert(g2, g5, posi = c(0.65, 0.65, 0.95, 0.95))

logData <- log(data[c("WT.K1","WT.K2","WT.K3","WT.N1","WT.N2","WT.N3")]+0.001)
logData$meanK <- rowMeans(logData[c("WT.K1","WT.K2","WT.K3")])
logData$meanN <- rowMeans(logData[c("WT.N1","WT.N2","WT.N3")])

logData$cluster <- data$cluster
ggplot(logData, aes(x=meanK, y=meanN, color=as.character(cluster))) +
  geom_point(size = 0.8) + scale_color_brewer(palette="Paired") + ggtitle("Expression moyenne suivant la condition et par cluster")


ggplot(logData, aes(x=(meanN+meanK)/2, y=meanN-meanK, color=as.character(cluster))) +
  geom_point(size = 0.8) + scale_color_brewer(palette="Paired") + ggtitle("Mais en fait... on retrouve un vulcano plot avec clustering!")
```



# Raw gene ontologies (peu intéressant comparé à la section suivante)

On cherche maintenant à comprendre d'un point de vue ontologie ces clusters de gènes : 

```{r GO}
nb_clust = max(clusters_per_genes)
for (clust in seq(1:nb_clust)){
  print(clust)
  genes = names(clusters_per_genes[which(clusters_per_genes == clust)])
  print(genes)
  mart = useMart(biomart="plants_mart",host="plants.ensembl.org", dataset = "athaliana_eg_gene")
  results <- getBM( filters = "ensembl_transcript_id", attributes = c("ensembl_transcript_id", "description", "external_gene_name"),
             values = genes, mart = mart)
  rownames(results) = results$ensembl_transcript_id
  r = results[genes,]; print(kable(r, caption = "Genes DE et leur GO"))
}
```

# GO enrichment

On utilise le package clusterProfiler.
On lui donne la liste des ID entrez, récupérés grâce à bioMart, la base de donnée d'AT.
L'ontologie peut être CC (cellular component), BP (biological process) ou MF(molecular function)).

On parvient à exhiber des processus biologiques sur représentés dans un cluster en faisant des tests sur une loi hypergéométrique, équivalente à une loi binomiale sans remise.

Pour une ontologie et un cluster, the p-value can be calculated using an hypergeometric distribution.

$p=1−∑_{i=0}^{k−1}\frac{\binom{M}{i}\binom{N−M}{n−i}}{\binom{N}{n}}$

In this equation, N is the total number of genes in the background distribution, M is the number of genes within that distribution that are annotated (either directly or indirectly) to the gene set of interest, n is the size of the list of genes of interest and k is the number of genes within that list which are annotated to the gene set. (à creuser un peu plus) The background distribution by default is all the genes that have annotation. P-values should be adjusted for multiple comparison. 

```{r GOenrich}
mart = useMart(biomart="plants_mart",host="plants.ensembl.org", dataset = "athaliana_eg_gene")
entrez <- getBM(filters = "ensembl_transcript_id", attributes = c("ensembl_transcript_id", "entrezgene_id"),
             values = DEgenes, mart = mart)

entrez <- entrez[!rownames(entrez) %in% which(duplicated(entrez$ensembl_transcript_id)), ]
rownames(entrez) <- entrez$ensembl_transcript_id
entrez$cluster <- data[entrez$ensembl_transcript_id, "cluster"]
entrez$regul <- data[entrez$ensembl_transcript_id, "regul"]

library(enrichplot)
ego <- enrichGO(gene = entrez$entrezgene_id,
                OrgDb = org.At.tair.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                readable = TRUE)

simpOnt <- simplify(ego, cutoff=0.7, by="p.adjust", select_fun=min)
simpOnt@result$Description

barplot(simpOnt, showCategory = 40, font.size = 5)
dotplot(simpOnt, showCategory = 40, font.size = 5)
emapplot(simpOnt, layout = "kk")
```

On obtient bien une clique associée au métabolisme des nitrates, transport d'ions, et réponse à la carence nutritionnelle.

Les autres, je ne sais pas spécialement comment les interprêter (demander à Antoine).

On cherche maintenant à faire cela pour chaque cluster, et les comparer.

```{r GOenrichClusters}

# on cree une liste de entrez id par cluster
entrezID <- list()
nb_clust = max(clusters_per_genes)
for (clust in seq(1:nb_clust)){
  #print(entrez[entrez$cluster == clust,]$ensembl_transcript_id)
  entrezID[[length(entrezID) + 1]] <- na.omit(entrez[entrez$cluster == clust,]$entrezgene_id)
}
names(entrezID) <- as.character(seq(1:nb_clust))

ck <- compareCluster(geneCluster = entrezID, fun = "enrichGO", OrgDb = org.At.tair.db, ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,)

dotplot(ck, x = ~Cluster, showCategory = 10, font.size = 5)
```
On a pas tous les clusters (Pas de 1 ni 8 par exemple), probablment car les plus petit n'ont pas pu donner lieu à des tests significatifs pour l'enrichissement.

On veut maintenant regarder des ontologies des gènes up-ou downrégulés

```{r GOenrichClustersReg}

# on cree une liste de entrez id par cluster
entrezIDreg <- list()
for (reg in c("up-regulated", "down-regulated")){
  #print(entrez[entrez$cluster == clust,]$ensembl_transcript_id)
  entrezIDreg[[length(entrezIDreg) + 1]] <- na.omit(entrez[entrez$regul == reg,]$entrezgene_id)
}
names(entrezIDreg) <- c("up-regulated", "down-regulated")

ckreg <- compareCluster(geneCluster = entrezIDreg, fun = "enrichGO", OrgDb = org.At.tair.db, ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,)

dotplot(ckreg, x = ~Cluster, showCategory = 20, font.size = 5)
```
C'est intéressant car on voit qu'il n'y a presque pas d'overlap entre les processus biologiques up-régulés et down-régulés. C'est rassurant dans le sens où la réponse aux nitrates, le transport des nitrates, la réponse à l'organonitrogen compond sont bien up-régulés, ainsi que des gènes impliqués dans la starvation.

Pas trop d'idées de pourquoi la photosynthèse est downrégulée (à demander à Antoine)